<!--#include virtual="/lab/header.html" -->


<h2>Previous Projects</h2>
This page summarizes activity in past projects, including <a
href="#constraints">Type Constraints</a>, <a
href="#specdiag">Specification Diagrams</a>, <a
href="#actors">Foundations of Actor Computation</a>, <a
href="#opsem">Foundations of Operational Semantics</a>, <a
href="#hardware">Hardware Verification</a>, and <a
href="#ctt">Constructive Type Theory</a>.

<p>


<a name="constraints"></a><h2>Type Constraints</h2>

Set constraint types are a generalization
of the standard notion of &quot;type&quot; to types which are sets of
constraints about program behavior.  Set constraints can capture more
details about the potential values that can be in a variable than a
traditional type system.  For instance, in an object-oriented language
such as Java, a variable declared as &quot;Serializable&quot; by the
Java type system can be any object which conforms to the Serializable
interface, but in practice that variable will only contain the
concrete objects which the program in fact serializes.  Knowing the
precise classes the program is serializing at that point is useful
both as a programming aid and as a tool to assist compilers in
generating faster code.  Recently we have developed and implemented a
tool which statically checks whether Java downcasts are legal using a
set-constraint-based mechanism.
<p>Type constraint systems are a very expressive form of type which can
be given to programs.  They are so expressive that they can in fact
fully record flow information about a program, namely this data value
could flow to that operation.</p>
<p><strong>Goal</strong>: The development of rich type constraint systems
for object-oriented programming languages.</p>  <p>
Our primary goal has been the extension of type constraint system to
allow for greater expressivity and usefulness in typing more
properties of programs. </p>
<p><strong>Uses:</strong></p>
<ul>
  <li>Fine-grained type systems for flexible object-oriented languages;
  <li>Fine-grained program analysis for compilers and other static
      analysis consumers
</ul>

<p>
<h4> Publications</h4>
<p>Tiejun Wang and Scott Smith, <a 
href="papers/ecoop01.pdf"><i>Precise Constraint-Based Type
Inference for Java</i></a>. ECOOP 2001. <a href="papers/toplas0X.pdf">Full version</a> submitted to TOPLAS.
<br>
<font size=-3>
Precise type information is invaluable for analysis and optimization
of object-oriented programs.  
Some forms of polymorphism found in
object-oriented languages pose significant difficulty for type inference, in
particular <em>data polymorphism</em>.  
Agesen's Cartesian Product
Algorithm (CPA) can analyze programs with parametric polymorphism in a
reasonably precise and efficient manner, but CPA loses precision for programs
with data polymorphism.  This paper presents a precise
constraint-based type inference system for Java.  It uses Data Polymorphic
CPA, a constraint-based type inference algorithm which extends CPA with the
ability to accurately and efficiently analyze data polymorphic
programs.  The system is implemented for the full Java language, and
is used to statically verify the correctness of Java downcasts. 
Benchmark results are given which show the system performs very well:
it is significantly more accurate and is nearly as efficient as CPA.
The implementation itself contains a number of novel optimizations 
which proved necessary to achieve scalability.</p>
</font>

<strong><a href="http://www.cs.jhu.edu/~wtj/precise/">Try Out the Inference
Algorithm Here!</a></strong>

<br><p><br>
Scott Smith and Tiejun Wang, <a 
href="papers/esop00.pdf"><i>Polyvariant Flow Analysis With
Constrained Types</i></a>. In Gert Smolka, editor,
<em>Proceedings of the 
2000 European Symposium on Programming (ESOP'00)</em>, volume 1782 of
<em>Lecture Notes in Computer Science</em>, pages 382--396. Springer
Verlag, March 2000. 
<br>
<font size=-3>
The basic idea behind improving the quality of a monovariant control
flow analysis such as 0CFA is the concept of <em>polyvariant</em>
analyses such as Agesen's Cartesian Product Algorithm (CPA) and
Shivers' <em>n</em>CFA.  In this paper we develop a novel framework for
polyvariant flow analysis based on Aiken-Wimmers constrained type
theory.  We develop instantiations of our framework to formalize
various polyvariant algorithms, including <em>n</em>CFA and CPA.  With our
CPA formalization, we show the call-graph based termination condition
for CPA will not always guarantee termination. We then develop a novel
termination condition and prove it indeed leads to a terminating
algorithm.  Additionally, we show how data polymorphism can be modeled
in the framework, by defining a simple extension to CPA that
incorporates data polymorphism.
</font>

<p>
V. Trifonov, S.Smith, <a href="papers/sas96.pdf"><i>Subtyping Constrained Types</i></a>,
<cite>Static Analysis Symposium (SAS) 1996, Lecture Notes in Computer
Science 1145</cite>, pp. 349-365. 
<br>
<font size=-3>
Constrained type systems are a natural generalization of 
Hindley/Milner type inference to languages with subtyping.
This paper develops several subtyping relations on constrained types.
We establish a full type abstraction property that equates an
operational notion of subtyping with a semantic notion based on
regular trees.  The decidability of this notion of subtyping is open;
we present a decidable approximation.  Subtyping constrained types has
application to functor signature matching. 
</font>

<p>
J. Palsberg, S. Smith, <a
href = "older-papers/cte.pdf"> <i>Constrained Types and their
Expressiveness</i></a>, <cite>TOPLAS</cite> <i>18</i> (5), Sept 1996, pp.
519-527.
<p>
Kim B. Bruce,
Luca Cardelli,
Giuseppe Castagna,
The Hopkins Objects Group,
Gary T. Leavens,
and
Benjamin Pierce.
On Binary Methods,
<cite>Theory and Practice of Object Systems</cite> <i>1</i> (3), 1995, pp.
217-238.
<br>
Department of Computer Science, Iowa State University,
<A HREF="ftp://ftp.cs.iastate.edu/pub/techreports/TR95-08/TR.ps.Z">
TR95-08</A>, May 1995.
<p>
J. Eifrig, S. Smith, V. Trifonov, 
<a href = "older-papers/sptio.pdf"> 
<i>Sound Polymorphic Type Inference for Objects</i></a>,
<cite>OOPSLA 1995</cite>, pp. 169-384.
<p>
J. Eifrig, S. Smith, V. Trifonov, <a href =
"papers/mfps95.pdf"> <i>Type Inference for
Recursively Constrained Types and its Application to OOP</i></a> (<a href =
"older-papers/ooinfer.pdf">longer version</a>),
<cite>Mathematical Foundations of Programming Semantics 1995</cite>
(Elsevier <a
href="http://www.elsevier.com/locate/entcs/"><cite>Electronic Notes in
Theoretical Computer Science</a></cite>, volume 1).

<p>
J. Eifrig, S. Smith, V. Trifonov, A. Zwarico,
<a href = "older-papers/aottsdi.pdf"> 
<i>Application of OOP Type Theory: State, Decidability, Integration</i></a>,
<cite>OOPSLA 1994</cite>, pp. 16-30.

<p>
J. Eifrig, S. Smith, V. Trifonov, A. Zwarico,
<a href = "older-papers/itoopls.pdf"> 
<i>An Interpretation of Typed OOP in a Language with State</i></a>,
<cite>Lisp and Symbolic Computation</cite> <b>8</b> (4), 1995, pp. 357-397.
<p>


J. Eifrig, S. Smith, V. Trifonov, A. Zwarico,
<a href = "older-papers/sioopls.pdf"> 
<i>A Simple Interpretation of OOP in a Language 
with State</i></a>,  
<cite> Workshop on State in Programming Languages 1993</cite>, pp. 1-36.<p>


<a name="specdiag"></a><h2>Specification Diagrams for Distributed Systems</h2>

<p>Specification diagrams are a graphical notation for the specification of
distributed systems.  The primary design goal is to make a form of
notation for defining message-passing behavior that is very
expressive, intuitively understandable, and that has a fully formal
underlying semantics.

<p>Specification diagrams are two-dimensional graphical structures.  Many
specification languages that have achieved widespread usage have a
graphical foundation: engineers can understand and communicate more
effectively by graphical means.  Popular graphical specification
languages include Universal Modelling Language (UML) and its
predecessors, and StateCharts.  Specification diagrams aim to be a
language with similar intuitive advantage but significantly greater
expressivity and formal underpinnings.

<p>Specification diagrams are highly suited to protocol specification
because they give a formal specification of the protocol that is also
readable by implementers.  We have specified various security protocols,
including the Needham-Schroeder protocol and TLS.


<h4>Publications</h4>
<p>Christian Skalka and Scott Smith, 
<a href="papers/tr02.pdf">Verifying
Security Protocols with Specification Diagrams</a>, Technical Report,
Johns Hopkins Unversity, 2002.</p>

<p>
Scott Smith and Carolyn Talcott.
<a href="papers/hosc02.pdf">Specification Diagrams for Actor Systems.</a>
<cite>Higher-order and Symbolic Computation (HOSC)</cite> 15, December 2002.

<p>
Scott Smith and Carolyn Talcott, <a href = "papers/fmoods99.pdf">
Modular Reasoning for Actor Specification Diagrams</a>.  Formal
Methods in Object-Oriented Distributed Systems, Florence, 1999.
Kluwer Academic Publishers, to appear.  <a href = "papers/fmoods99-slides.pdf">
The slides from the FMOODS talk</a>.
<p>
Scott Smith, <a href = "papers/hoots98.pdf"> Specification
Diagrams for Actor Systems</a>. Higher Order Operational Techniques in Semantics II,
<cite>Electronic Notes in Theoretical Computer Science</a></cite>,
1998. 

<p>


<a name="actors"><h2>Foundations of Actor Computation</h2>
</a><p>The goal of this project is the development of rigorous semantic
foundations for actor computation. 

<p>Here are a few features of the models we developed.</p>
<ul>
<li> A rigorous reworking of the Actor model of computation
<li> Operational semantics of executions given.
<li> Only fair executions considered, for unfair executions never
arise in practice.
<li> Observational equivalence and methods for proving observational
equivalence in the presence of fairness are defined.
<li> Explicit, dynamic modeling of external agents and their
interactions. 
</ul>


<h4>Publications</h4>

<p>G. Agha, I. Mason, S. Smith, C. Talcott,
<a href = "older-papers/ffac.pdf"> A Foundation for
Actor Computation.</a> <cite>Journal of Functional Programming</cite>,
volume 7,   pages 1--72, 1997.

<p>G. Agha, I. Mason, S. Smith, C. Talcott, <a href = "older-papers/ttac.pdf">
Towards a Theory of Actor Computation.</a> <cite>Third International
Conference on Concurrency Theory (CONCUR), Lecture Notes in Computer
Science</cite> 630, 1992.
<p>
<a name="opsem"><h2>Foundations of Operational Semantics</h2>
</a><p>This line of research addresses
foundational issues in operational semantics.  The main thrust has been
to show how denotational concepts such as pre-ordering on elements,
directed set, least fixed-point, fixed point induction,
finite/compact/algebraic elements, and ideal models of types can be
"ported" to a purely operational semantic development.  The goal of
this research is to give full and faithful semantics to
languages for which denotational semantics falls short. 



<h4>Publications</h4>

<p>I. Mason, S. Smith, C. Talcott, <a href = "older-papers/fosdt.pdf"> From
Operational Semantics to Domain Theory</a>, <cite>Information and
Computation</cite> volume 128, pages 26--47, 1996.<br>

This paper presents the operational theory for a pure functional language.


<p>S. Smith, <a href = "older-papers/fods.pdf"> 
From Operational to Denotational Semantics. </a><cite>Conference on
Mathematical Foundations of Programming Language Semantics, Lecture
Notes in Computer Science</cite> 598, Springer-Verlag, 1992. 
(downloadable version is an extended version, but this paper is
generally subsumed by the previous)</p>


<p>S. Smith, <a href = "older-papers/hoots.pdf">The Coverage of Operational Semantics </a>.
In <cite>Higher Order Techniques in Operational
Semantics</cite>, A. Gordon and A. Pitts, editors, Cambridge
University Press.  <br>
This paper studies how more complex languages
may be fully and faithfully embedded in simpler ones.  By such
embeddings, some results which hold for purely functional languages
can be lifted to languages with state and objects.  A conjecture is
given on how 
to characterize the finite or compact elements for a language with
state; the problem remains 
open however.</p>

<p>F. Honsell, I. Mason, S. Smith, C. Talcott, <a href =
"older-papers/vtloe.pdf"> A Variable Typed 
Logic of Effects.</a> <cite>Information and Computation</cite> volume
119, pages 55-90, 1995.
This paper develops a modal logic for a programming language with
state.
<p>

<a name="hardware"><h2>Hardware Verification</h2>
</a>
<p>In collaboration with Amy Zwarico we defined a formal language for
specifying asynchronous digital circuits that is based on Hoare's CSP,
and verified a translation of these circuit specifications to hardware
devices (collections of gates).  The translation was proven correct by
defining a formal operational notion of equivalence, and incrementally
translating the specification to the circuit in small steps that
preserve equivalence.  Numerous informal arguments of correctness of
similar synthesis methods exist, but this work is the first complete,
rigorous proof of correctness of such a method.  Some other features
of this project include the following.</p>

<ul>
<li> The translation is defined by a set of rewrite rules, broken into five phases.
<li> A new notion of "translational equivalence" is defined to state how 
a translation preserves meaning when the language itself is changing.
<li> Only fair executions considered, for gates are inherently fair.  
This is some of the first work in circuit theory to consider fairness.
</ul>


<h4>Publications</h4>

<p>S. Smith, A. Zwarico, <a href = "older-papers/ccsdac.pdf"> 
Correct Compilation of Specifications to Deterministic Asynchronous
Circuits. </a> <cite> Formal Methods in System Design</cite> volume 7,
1995.</p>


<p>
S. Smith, A. Zwarico, <a href = "older-papers/ccsdac0.pdf"> 
Correct Compilation of Specifications to Deterministic Asynchronous
Circuits. </a> <cite>Correct Hardware Design Methodologies</cite>, Arles,
France, May 1993, <cite>Lecture Notes in Computer Science</cite>,
volume 683.

<p>

<a name="ctt"><h2>Constructive Type Theory</h2>
</a><p>The main contributions
were in developing type systems that allow both partial and total
functions to be typed in a single type theory. 

<h4>Publications</h4>
<p>S. Smith, <a href = "older-papers/hpttt.pdf"> 
Hybrid Partial-Total Type Theory.</a><cite> International Journal 
of Foundations of Computer Science</cite> volume 6, 235-263, 1995.
<br>
This paper is a simplified version of the results in my PhD thesis.</p>

S. Smith, <a href = "older-papers/rsctt.pdf"> Reflective
Semantics of Constructive Type Theory.</a> <cite>Constructivity in
Computer Science</cite>, Springer-Verlag LNCS 613, 1992.  
</p>

<p>
S. Smith, <a href = "older-papers/erptt.pdf"> 
Extracting Recursive Programs in Type Theory</a>.
<cite> AMAST 1991, Springer-Verlag Workshops in Computing Series.</cite>
</p>
<p>
S. Smith, <a href = "older-papers/thesis.pdf"> 
Partial Objects in Type Theory (PhD Thesis) </a> 
</p>


<p>
Computational foundations of basic recursive function theory.  
<cite>Theoretical Computer Science</cite>, December 1993 (with Robert
Constable).
</p>

<p><cite>Implementing Mathematics with the Nuprl Proof Development
System</cite>. Englewood Cliffs: Prentice Hall, 1986 (with Robert
Constable, et. al.).</p>


<!--#include virtual="/lab/footer.html" -->
