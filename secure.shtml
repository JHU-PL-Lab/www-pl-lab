<!--#include virtual="header.html" -->

<h2>Secure Language Architectures</h2>
<p><strong>Goal</strong>: The development of secure, programming-language-based
access control and information flow constructs for statically and
dynamic enforcement of security
guarantees.  </p>  
<p>

Some of the most challenging research problems in computer science in
the next twenty years will be centered around security issues.
Security problems arise at many levels, from cryptographic security to
secure network architectures to secure operating systems
architectures.  Programming language architectures are another
important layer that must also be
secured.  The Java JDK now includes a fairly complete Security
Architecture which supports code-based access control.  But, this area
is really just beginning, and our goal is to make fundamental
contributions to the programming language security architectures that
eventually become widely established.

<p> Our efforts in this area have been centered around the following
topics.

<ul>
  <li><strong>Developing type-based models of security.</strong>  Type-based systems give
static, declarative security guarantees and so are an important level
at which to place security policies.  Additionally, a static security
policy requires no run-time overhead of explicit security checks.  We
have developed static type systems corresponding to the Java Security
Architecture
  <li><strong>Type-based models for information flow.</strong>  We are
  focusing on making <em>realistic</em> type-based information flow
  systems, where the flow labels can be completely inferred, and a
  focus on the I/O boundary as the (sole) location where information
  flow levels should be declared.
  <li><strong>Dynamic information flow.</strong> Using ideas from
  static analysis, we are working on developing run-time systems for
  monitoring information flow.  This is a challenging problem due to
  the possibility of indirect leakage of information.
</ul> </P>


<p>
<h3>Publications</h3>
<ul>
  <li>Paritosh Shroff and Scott F. Smith.  <a
href="http://www.cs.jhu.edu/~pari/timing.pdf">Securing Timing Channels
at Runtime</a>, Technical Report, July
2008.
<p>
<font size=-3>We propose a general purpose runtime framework to secure timing 
channels. Our technique supports higher-order function invocations 
and computations looping on secret data, features which none of 
the existing approaches fully allow. We provably eliminate external and internal timing channels in both sequential and concurrent 
settings, in presence of deterministic as well as nondeterministic 
schedulers. There is a price to be paid, however â€“ the high computation may have to be disrupted; the low computation is nevertheless guaranteed to be unaffected. We illustrate how our approach 
can be realized on standard computing platforms. 
</font>
<p><li>
Paritosh Shroff, Scott F. Smith, and Mark Thober
<I><a href="papers/dynamic-monitoring.pdf">Dynamic Dependency Monitoring to Secure Information Flow</a></I>.
<a href="http://www.dsi.unive.it/CSF20/">CSF 2007</a>: 20th IEEE Computer Security Foundations Symposium.
<a href="papers/dynamic-monitoring-slides.pdf">Slides</a>.
<a href="papers/dynamic-monitoring-tr.pdf">Technical Report</a>.
(<i>Best Paper Award</i>)
<p>

<font size=-3> Although static systems for information
flow security are 
well-studied, few works address run-time information flow monitoring.
Run-time information flow control offers distinct advantages in
precision and in the ability to support dynamically defined policies.
To this end, we here develop a new run-time information flow system
based on the run-time tracking of indirect dependencies between
program points.  Our system tracks both direct and indirect
information flows, and noninterference results are proved.
</font>
<li>Scott F. Smith, and Mark Thober
<I>
<a href="papers/usable-infoflow-plas07.pdf">
Improving Usability of Information Flow Security in Java</a></I>. 
ACM SIGPLAN Workshop on Programming Languages and Analysis for 
Security (PLAS 2007).
<a href="papers/usable-infoflow-tr07.pdf">
Technical Report</a>
<p>
<font size=-3>
This paper focuses on improving the usability of information flow type
systems.  We present a static information flow type inference system
for Middleweight Java (MJ) which automatically infers information flow
labels, thus avoiding the need for a multitude of program annotations.
Additionally, policies need only be specified on IO channels, the
critical flow boundary.  Our type system includes a high degree of
parametric polymorphism, necessary to allow classes to be used in
multiple security contexts, and to properly distinguish the security
policies of different IO channels.

We prove a noninterference property for programs that interactively
input and output data.  We then describe a mechanism that allows users
to define top-level policies, which automatically inserts the security
policies at the proper points in the program.  This provides the
further benefit that whomever is defining the policy does not
necessarily need intimate knowledge of the program source.
</font>

<p>
<li>Scott Smith and Mark Thober
<I><a href="http://www.cs.jhu.edu/~mthober/papers/smith-thober-plas06.pdf">Refactoring Programs to Secure Information
Flows</a></I>
ACM SIGPLAN Workshop on Programming Languages and Analysis for
Security (PLAS), 2006.
<p>
<font size=-3> Adding a sound information flow security
policy to an existing program is a difficult task that requires major
analysis of and changes to the program. In this paper we show how
refactoring programs into distinct components of high and low
security is a useful methodology to aid in the production of programs
with sound information flow policies. Our methodology proceeds as
follows. Given a program with no information flow controls, a program
slicer is used to identify code that depends on high security
inputs. High security code so identified is then refactored into a
separate component, which may be accessed by the low security
component via public method calls. A security policy that labels input
data and checks the output points can then enforce the desired
end-to-end security property. Controlled information releases can
occur at explicit declassification points if deemed safe. The result
is a well-engineered program with explicit interfaces between
components of different security levels.  </font>

<p><li>
Scott Smith and Mark Thober
<I><a href="http://www.cs.jhu.edu/~mthober/securingdata06.pdf">Securing Data
	  at Java IO Boundaries</a></I>
Draft.

<p>
<font size=-3> We present an information flow type system
for Featherweight Java, taking a programmer-centered view by requiring
minimal program annotations, and focusing on IO points, the most
critical flow boundary.  Our static type inference system
automatically infers information flow labels, thus eliminating the
need for explicit program annotations.  We prove type soundness and a
noninterference property using an extensible operational approach. On
top of this system, we provide an analysis that extracts all
information flowing in and out of the IO points of a program.  Global
program flows can then be observed, and policies can be set to control
these flows.  We argue that controlling data at input and output
points is ultimately the only data security borders that matter, and
our system allows programmers to focus on this dimension.
</font>

<p><li>Fran&#231;ois
Pottier, Christian Skalka and Scott Smith.
<I><a
href="papers/toplas05.pdf">
A Systematic Approach to Static Access Control</a></I>, TOPLAS, to appear.
<p>

<font size=-3>The Java Security Architecture includes a dynamic mechanism for
enforcing access control checks, the so-called stack inspection
process. While the architecture has several appealing features, access
control checks are all implemented via dynamic method calls. This is a
highly non-declarative form of specification which is hard to read,
and which leads to additional run-time overhead. This paper develops
type systems which can statically guarantee the success of these
checks. Our systems allow security properties of programs to be
clearly expressed within the types themselves, which thus serve as
static declarations of the security policy. We develop these systems
using a systematic methodology: we show that the security-passing
style translation, proposed by Wallach, Appel and Felten as a <em>dynamic</em>
implementation technique, also gives rise to <em>static</em> security-aware
type systems, by composition with conventional type systems. To define
the latter, we use the general HM(X) framework, and easily construct
several constraint- and unification-based type systems.
</font>

<p><li>Christian Skalka and Scott Smith.<I>
<a
href="papers/aplas04.pdf">
History
Effects and Verification</a></I>.  In Asian Programming Languages Symposium, November 2004.<p>

<font size=-3>Trace effects are statically generated program abstractions, that can
be model checked for verification of assertions in a temporal program
logic. In this paper we develop a type and effect analysis for
obtaining trace effects of Object Oriented programs in Featherweight
Java. We observe that the analysis is significantly complicated by the
interaction of trace behavior with inheritance and other Object
Oriented features, particularly overridden methods, dynamic dispatch,
and downcasting. We propose an expressive type and effect inference
algorithm combining polymorphism and subtyping/subeffecting
constraints to obtain a flexible trace effect analysis in this
setting, and show how these techniques are applicable to Object
Oriented features.
</font>

<p><li>

Christian Skalka, Scott Smith, and David Van Horn. <i><a
href="papers/aiool05.pdf">A Type and Effect System for Flexible
Abstract Interpretation of Java</a></i>. In Proceedings of the ACM
Workshop on Abstract Interpretation of Object Oriented Languages,
Electronic Notes in Theoretical Computer Science, January 2005.
<p>
<font size=-3>
This paper describes a flexible type and effect inference system for
Featherweight Java (FJ). The effect terms generated by static type and
effect inference embody the abstract interpretation of program event
sequences. Flexibility in the analysis is obtained by post-processing
of inferred effects, allowing a modular adaptation to extensions of
the language. Several example transformations are discussed, including
how inferred effects can be transformed to reflect the impact of
exceptions on FJ control flow.
</font>

<p><li>Christian Skalka and Scott Smith. <I>
<a
href="papers/entcs03.pdf">
Set
Types and Applications</a></I>, Worskop on Types in Programming
(TIP02).  Electronic Notes in Theoretical Computer Science, 75, 2003.
<p>
<font size=-3>
We present pml, a programming language that includes primitive sets
and associated operations. The language is equipped with a precise
type discipline that statically captures dynamic properties of sets,
allowing runtime optimizations. We demonstrate the utility of pmlB by
showing how it can serve as a practical implementation language for
higher-level programming language based security systems, and
characterize pml by comparing the expressiveness of pmlB sets with
enumerations.
</font>
<p><li>
Christian Skalka and Scott
Smith. <I>
<a
href="papers/fcs02.pdf">
Static
Use-Based Object Confinement</a></I>, Workshop on Foundations of
Computer 
Security (FCS02).  <a href="papers/ijis05.pdf">Full version</a> appearing in Springer International
Journal of Information Security, 4(1-2), 2005. 
<p>
<font size=-3>
The confinement of object references is a significant security concern
for modern programming languages. We define a language that serves as
a uniform model for a variety of confined object reference systems. A
use-based approach to confinement is adopted, which we argue is more
expressive than previous communication-based approaches. We then
develop a readable, expressive type system for static analysis of the
language, along with a type safety result demonstrating that run-time
checks can be eliminated. The language and type system thus serve as a
reliable, declarative and efficient foundation for secure
capability-based programming and object confinement.
</font>
<p><li>
Fran&ccedil;ois Pottier, Christian Skalka, and Scott Smith. 
<a href="papers/esop01.pdf">
<i>A Systematic
Approach to Static Access Control</i></a>.  European Symposium on Programming
(ESOP) 2001, April 2001.
<p>

<font size=-3>
The Java JDK 1.2 Security Architecture includes a dynamic mechanism
for enforcing access control checks, so-called <em>stack
inspection</em>. This paper studies type systems which can statically
guarantee the success of these checks.
We develop these systems using a new, systematic methodology:
we show that the security-passing style translation, proposed
by Wallach and Felten as a <em>dynamic</em> implementation technique,
also gives rise to <em>static</em> security-aware type systems, by
composition with conventional type systems.
To define the latter, we use the general HM(X) framework, and easily construct several
constraint- and unification-based type systems. They offer
significant improvements on a previous type system
for JDK access control, both in terms of expressiveness and in terms
of readability of inferred type specifications.
</font>

<p><li>
Christian Skalka and Scott Smith. 
<a href="papers/icfp00.pdf"><i>Static
Enforcement of Security with Types</i></a>, <em>2000 International Conference
on Functional Programming (ICFP00)</em>, September 2000.
<p>
<font size=-3>
  A number of security systems for programming languages have recently
  appeared, including systems for enforcing some form of
  <em>access control</em>.  The Java JDK 1.2 security architecture is
  one such system that is widely studied and used. While the
  architecture has many appealing features, access control checks are
  all implemented via dynamic method calls.  This is a highly
  non-declarative form of specification which is hard to read, and
  which leads to additional run-time overhead.  In this paper, we
  present a novel <em>security type system</em> that enforces the same
  security guarantees as Java Stack Inspection, but via a static type
  system with no additional run-time checks.  The system allows
  security properties of programs to be clearly expressed within the
  types themselves.  We also define and prove correct an inference
  algorithm for security types, meaning that the system has the
  potential to be layered on top of the existing Java architecture,
  without requiring new syntax.</p>
</font>


</ul>
<!--#include virtual="footer.html" -->